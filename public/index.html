<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Driver Monitoring System - AI-Powered Safety</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" type="image/x-icon" href="/favicon.ico">

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #fafafa;
  color: #1a1a1a;
  min-height: 100vh;
}

/* ========== HEADER ========== */
.header {
  background: #ffffff;
  border-bottom: 1px solid #e0e0e0;
  padding: 0 40px;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 1000;
  box-shadow: 0 1px 2px rgba(0,0,0,0.04);
}

.logo {
  font-size: 20px;
  font-weight: 700;
  color: #000;
  text-decoration: none;
  letter-spacing: -0.3px;
}

.nav-links {
  display: flex;
  gap: 20px;
  align-items: center;
}

.nav-link {
  color: #666;
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
  transition: color 0.2s;
}

.nav-link:hover {
  color: #000;
}

.github-link {
  background: #000;
  color: #fff;
  padding: 8px 18px;
  border-radius: 6px;
  text-decoration: none;
  font-size: 13px;
  font-weight: 600;
  transition: all 0.2s;
}

.github-link:hover {
  background: #333;
  transform: translateY(-1px);
}

/* ========== HERO SECTION ========== */
.hero-container {
  max-width: 1280px;
  margin: 0 auto;
  padding: 60px 40px 80px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 60px;
  align-items: center;
}

.hero-content {
  max-width: 560px;
}

.hero-title {
  font-size: 48px;
  font-weight: 800;
  color: #000;
  line-height: 1.1;
  margin-bottom: 20px;
  letter-spacing: -1.5px;
}

.hero-subtitle {
  font-size: 18px;
  color: #555;
  line-height: 1.5;
  margin-bottom: 14px;
  font-weight: 500;
}

.hero-description {
  font-size: 15px;
  color: #777;
  line-height: 1.7;
  margin-bottom: 28px;
}

.feature-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 32px;
}

.feature-item {
  display: flex;
  align-items: center;
  font-size: 14px;
  color: #444;
  font-weight: 500;
}

.feature-icon {
  width: 18px;
  height: 18px;
  background: #10b981;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 11px;
  font-weight: bold;
  margin-right: 10px;
  flex-shrink: 0;
}

.performance-note {
  font-size: 12px;
  color: #999;
  font-style: italic;
  padding: 12px 16px;
  background: #f5f5f5;
  border-left: 3px solid #ddd;
  border-radius: 4px;
}

/* ========== UPLOAD SECTION ========== */
.upload-section {
  background: #fff;
  border-radius: 12px;
  padding: 36px;
  border: 1px solid #e0e0e0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.04);
}

.upload-header {
  text-align: center;
  margin-bottom: 28px;
}

.upload-header h2 {
  font-size: 22px;
  font-weight: 700;
  color: #000;
  margin-bottom: 6px;
  letter-spacing: -0.5px;
}

.upload-header p {
  font-size: 13px;
  color: #666;
}

.upload-area {
  border: 2px dashed #d0d0d0;
  border-radius: 10px;
  padding: 50px 30px;
  text-align: center;
  cursor: pointer;
  transition: all 0.25s;
  background: #fafafa;
  margin-bottom: 20px;
}

.upload-area:hover {
  border-color: #10b981;
  background: #f0fdf4;
}

.upload-area.has-files {
  border-color: #10b981;
  background: #f0fdf4;
  border-style: solid;
}

.upload-icon {
  font-size: 42px;
  margin-bottom: 14px;
  opacity: 0.8;
}

.upload-text {
  font-size: 15px;
  font-weight: 600;
  color: #333;
  margin-bottom: 6px;
}

.upload-hint {
  font-size: 13px;
  color: #888;
}

.file-count {
  font-size: 13px;
  color: #10b981;
  font-weight: 600;
  margin-top: 10px;
}

#fileInput {
  display: none;
}

.button-group {
  display: flex;
  gap: 10px;
}

.btn {
  flex: 1;
  padding: 14px 22px;
  border: none;
  border-radius: 8px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-primary {
  background: #10b981;
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: #059669;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
}

.btn-secondary {
  background: #fff;
  color: #555;
  border: 1px solid #d0d0d0;
}

.btn-secondary:hover {
  background: #f5f5f5;
  border-color: #bbb;
}

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

/* ========== PROCESSING OVERLAY ========== */
.processing-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.85);
  z-index: 9999;
  align-items: center;
  justify-content: center;
}

.processing-content {
  background: white;
  padding: 44px 56px;
  border-radius: 12px;
  text-align: center;
  max-width: 480px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

.processing-content h3 {
  font-size: 20px;
  font-weight: 700;
  color: #000;
  margin-bottom: 20px;
  letter-spacing: -0.3px;
}

.progress-container {
  width: 100%;
  background: #f0f0f0;
  border-radius: 6px;
  height: 6px;
  overflow: hidden;
  margin-bottom: 14px;
}

.progress-fill {
  height: 100%;
  background: #10b981;
  width: 0%;
  transition: width 0.3s ease;
}

.processing-text {
  font-size: 13px;
  color: #666;
  font-weight: 500;
}

/* ========== RESPONSIVE ========== */
@media (max-width: 1024px) {
  .hero-container {
    grid-template-columns: 1fr;
    gap: 50px;
    padding: 40px 30px 60px;
  }
  
  .hero-title {
    font-size: 38px;
  }
  
  .header {
    padding: 0 30px;
  }
  
  .upload-section {
    padding: 28px;
  }
}

@media (max-width: 640px) {
  .hero-title {
    font-size: 32px;
  }
  
  .header {
    padding: 0 20px;
  }
  
  .nav-links {
    gap: 12px;
  }
  
  .github-link {
    padding: 6px 14px;
    font-size: 12px;
  }
}
</style>

</head>

<body>
<!-- HEADER -->
<div class="header">
  <a href="index.html" class="logo">DMS</a>
  <div class="nav-links">
    <a href="about.html" class="nav-link">About</a>
    <a href="https://github.com/AlbatrossC/Driver-Monitoring-System" target="_blank" class="github-link">GitHub</a>
  </div>
</div>

<!-- HERO SECTION -->
<div class="hero-container">
  <div class="hero-content">
    <h1 class="hero-title">Driver Monitoring System</h1>
    <p class="hero-subtitle">AI-Powered Real-Time Safety Analysis</p>
    <p class="hero-description">
      Advanced driver behavior detection running entirely in your browser. 
      No server uploads, complete privacy, powered by client-side machine learning.
    </p>

    <div class="feature-list">
      <div class="feature-item">
        <div class="feature-icon">‚úì</div>
        <span>100% Browser-Based Processing</span>
      </div>
      <div class="feature-item">
        <div class="feature-icon">‚úì</div>
        <span>Multiple Behavior Detection (Drowsiness, Phone Usage, Seatbelt)</span>
      </div>
      <div class="feature-item">
        <div class="feature-icon">‚úì</div>
        <span>Real-Time Safety Warnings</span>
      </div>
      <div class="feature-item">
        <div class="feature-icon">‚úì</div>
        <span>Complete Privacy - No Data Leaves Your Device</span>
      </div>
    </div>

    <div class="performance-note">
      Note: Performance may vary based on your device's hardware capabilities. 
      Modern browsers with WebAssembly support required.
    </div>
  </div>

  <div class="upload-section">
    <div class="upload-header">
      <h2>Upload Images for Analysis</h2>
      <p>Select one or multiple driver images to analyze</p>
    </div>

    <div class="upload-area" id="uploadArea">
      <div class="upload-icon">üìÅ</div>
      <div class="upload-text">Click to upload images</div>
      <div class="upload-hint">JPG, PNG supported - Multiple files allowed</div>
      <input type="file" id="fileInput" accept="image/*" multiple />
      <div class="file-count" id="fileCount" style="display: none;"></div>
    </div>

    <div class="button-group">
      <button class="btn btn-secondary" id="clearBtn" style="display:none;">Clear</button>
      <button class="btn btn-primary" id="processBtn" disabled>Process Images</button>
    </div>
  </div>
</div>

<!-- PROCESSING OVERLAY -->
<div class="processing-overlay" id="processingOverlay">
  <div class="processing-content">
    <h3>Processing Images</h3>
    <div class="progress-container">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="processing-text" id="processingText">Initializing models...</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"></script>

<script>
/* ================= CONFIGURATION ================= */
ort.env.wasm.numThreads = navigator.hardwareConcurrency || 4;
ort.env.wasm.simd = true;

const MODEL_PATHS = {
  chaitanya: "/static/models/chaitanya_best.onnx",
  soham: "/static/models/soham_best.onnx"
};

const INPUT_SIZE = 640;
const CONF_THRES = 0.25;
const IOU_THRES = 0.45;

/* ================= GLOBAL MODEL CACHE ================= */
let modelCache = {
  chaitanya: null,
  soham: null
};

/* ================= STATE ================= */
let uploadedImages = [];
let processedResults = [];

/* ================= PRELOAD MODELS (LAZY) ================= */
async function preloadModels(progressCallback) {
  if (modelCache.chaitanya && modelCache.soham) {
    return; // Already loaded
  }
  
  try {
    if (!modelCache.chaitanya) {
      progressCallback('Loading Chaitanya model...', 10);
      modelCache.chaitanya = await ort.InferenceSession.create(MODEL_PATHS.chaitanya, {
        executionProviders: ['wasm'],
        graphOptimizationLevel: 'all'
      });
      console.log('‚úì Chaitanya model loaded');
    }
    
    progressCallback('Loading Chaitanya model...', 30);
    
    if (!modelCache.soham) {
      progressCallback('Loading Soham model...', 40);
      modelCache.soham = await ort.InferenceSession.create(MODEL_PATHS.soham, {
        executionProviders: ['wasm'],
        graphOptimizationLevel: 'all'
      });
      console.log('‚úì Soham model loaded');
    }
    
    progressCallback('Models ready', 60);
  } catch (error) {
    console.error('Model loading error:', error);
    throw new Error('Failed to load AI models: ' + error.message);
  }
}

/* ================= FILE HANDLING ================= */
document.getElementById('uploadArea').onclick = () => {
  document.getElementById('fileInput').click();
};

document.getElementById('fileInput').onchange = (e) => {
  const files = Array.from(e.target.files);
  if (files.length === 0) return;
  
  uploadedImages = [];
  let loadedCount = 0;
  
  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = (event) => {
      uploadedImages.push({
        name: file.name,
        dataUrl: event.target.result
      });
      
      loadedCount++;
      
      if (loadedCount === files.length) {
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.classList.add('has-files');
        
        const fileCount = document.getElementById('fileCount');
        fileCount.style.display = 'block';
        fileCount.textContent = `${files.length} file${files.length > 1 ? 's' : ''} selected`;
        
        document.getElementById('processBtn').disabled = false;
        document.getElementById('clearBtn').style.display = 'block';
      }
    };
    reader.readAsDataURL(file);
  });
};

document.getElementById('clearBtn').onclick = () => {
  uploadedImages = [];
  document.getElementById('fileInput').value = '';
  document.getElementById('processBtn').disabled = true;
  document.getElementById('clearBtn').style.display = 'none';
  
  const uploadArea = document.getElementById('uploadArea');
  uploadArea.classList.remove('has-files');
  
  const fileCount = document.getElementById('fileCount');
  fileCount.style.display = 'none';
};

document.getElementById('processBtn').onclick = async () => {
  if (uploadedImages.length === 0) return;
  
  const overlay = document.getElementById('processingOverlay');
  const progressFill = document.getElementById('progressFill');
  const processingText = document.getElementById('processingText');
  
  overlay.style.display = 'flex';
  
  const updateProgress = (text, percent) => {
    processingText.textContent = text;
    progressFill.style.width = percent + '%';
  };
  
  try {
    // Load models first
    await preloadModels(updateProgress);
    
    updateProgress('Processing images...', 65);
    
    processedResults = [];
    
    for (let i = 0; i < uploadedImages.length; i++) {
      const imageData = uploadedImages[i];
      updateProgress(`Processing image ${i + 1} of ${uploadedImages.length}...`, 65 + (i / uploadedImages.length) * 30);
      
      const img = await loadImage(imageData.dataUrl);
      const prep = preprocess(img);
      
      // Run inference
      const chaitanyaResult = await modelCache.chaitanya.run({ images: prep.tensor });
      const sohamResult = await modelCache.soham.run({ images: prep.tensor });
      
      const chaitanyaDetections = parseDetections(chaitanyaResult, prep, img.width, img.height, 'chaitanya');
      const sohamDetections = parseDetections(sohamResult, prep, img.width, img.height, 'soham');
      
      const finalDetections = confidenceBasedMerge(chaitanyaDetections, sohamDetections);
      
      processedResults.push({
        imageData: imageData,
        detections: finalDetections,
        rawChaitanya: chaitanyaDetections,
        rawSoham: sohamDetections
      });
    }
    
    updateProgress('Complete! Redirecting...', 100);
    
    sessionStorage.setItem('dmsResults', JSON.stringify(processedResults));
    
    setTimeout(() => {
      window.location.href = 'results.html';
    }, 400);
    
  } catch (error) {
    console.error('Processing error:', error);
    alert('Error processing images: ' + error.message);
    overlay.style.display = 'none';
  }
};

/* ================= HELPER FUNCTIONS ================= */
function loadImage(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}

function preprocess(img) {
  const canvas = document.createElement('canvas');
  canvas.width = INPUT_SIZE;
  canvas.height = INPUT_SIZE;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = '#808080';
  ctx.fillRect(0, 0, INPUT_SIZE, INPUT_SIZE);
  
  const scale = Math.min(INPUT_SIZE / img.width, INPUT_SIZE / img.height);
  const newWidth = img.width * scale;
  const newHeight = img.height * scale;
  const offsetX = (INPUT_SIZE - newWidth) / 2;
  const offsetY = (INPUT_SIZE - newHeight) / 2;
  
  ctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
  
  const imageData = ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
  const pixels = imageData.data;
  const float32Data = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
  
  for (let i = 0; i < INPUT_SIZE * INPUT_SIZE; i++) {
    float32Data[i] = pixels[i * 4] / 255.0;
    float32Data[INPUT_SIZE * INPUT_SIZE + i] = pixels[i * 4 + 1] / 255.0;
    float32Data[2 * INPUT_SIZE * INPUT_SIZE + i] = pixels[i * 4 + 2] / 255.0;
  }
  
  return {
    tensor: new ort.Tensor('float32', float32Data, [1, 3, INPUT_SIZE, INPUT_SIZE]),
    scale: scale,
    offsetX: offsetX,
    offsetY: offsetY
  };
}

const CHAITANYA_CLASSES = ['Cigarette', 'Drinking', 'Eating', 'Phone', 'Seatbelt'];
const SOHAM_CLASSES = ['Distracted', 'Drinking', 'Drowsy', 'Eating', 'PhoneUse', 'SafeDriving', 'Seatbelt', 'Smoking'];

const UNIFIED_MAPPING = {
  'Cigarette': 'Smoking',
  'Smoking': 'Smoking',
  'Drinking': 'Drinking',
  'Eating': 'Eating',
  'Phone': 'Phone Usage',
  'PhoneUse': 'Phone Usage',
  'Seatbelt': 'Seatbelt',
  'Distracted': 'Distracted',
  'Drowsy': 'Drowsy',
  'SafeDriving': 'Safe Driving'
};

function parseDetections(result, prep, imgWidth, imgHeight, modelName) {
  const classes = modelName === 'chaitanya' ? CHAITANYA_CLASSES : SOHAM_CLASSES;
  const outputName = Object.keys(result)[0];
  const output = result[outputName];
  const data = output.data;
  const shape = output.dims;
  
  let numClasses, numDetections;
  
  if (shape.length === 3 && shape[0] === 1) {
    numClasses = shape[1] - 4;
    numDetections = shape[2];
  } else {
    console.error('Unexpected output shape:', shape);
    return [];
  }
  
  const detections = [];
  
  for (let j = 0; j < numDetections; j++) {
    let maxScore = 0;
    let maxIndex = 0;
    
    for (let k = 0; k < numClasses; k++) {
      const score = data[(4 + k) * numDetections + j];
      if (score > maxScore) {
        maxScore = score;
        maxIndex = k;
      }
    }
    
    if (maxScore > CONF_THRES) {
      const x = data[j];
      const y = data[numDetections + j];
      const w = data[2 * numDetections + j];
      const h = data[3 * numDetections + j];
      
      const x1 = Math.max(0, (x - w / 2 - prep.offsetX) / prep.scale);
      const y1 = Math.max(0, (y - h / 2 - prep.offsetY) / prep.scale);
      const x2 = Math.min(imgWidth, (x + w / 2 - prep.offsetX) / prep.scale);
      const y2 = Math.min(imgHeight, (y + h / 2 - prep.offsetY) / prep.scale);
      
      const originalClass = classes[maxIndex];
      const unifiedClass = UNIFIED_MAPPING[originalClass] || originalClass;
      
      detections.push({
        bbox: [x1, y1, x2, y2],
        conf: maxScore,
        cls: unifiedClass,
        originalClass: originalClass,
        source: modelName === 'chaitanya' ? 'Chaitanya' : 'Soham'
      });
    }
  }
  
  return detections;
}

function iou(box1, box2) {
  const x1 = Math.max(box1[0], box2[0]);
  const y1 = Math.max(box1[1], box2[1]);
  const x2 = Math.min(box1[2], box2[2]);
  const y2 = Math.min(box1[3], box2[3]);
  
  const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
  const area1 = (box1[2] - box1[0]) * (box1[3] - box1[1]);
  const area2 = (box2[2] - box2[0]) * (box2[3] - box2[1]);
  const union = area1 + area2 - intersection;
  
  return union > 0 ? intersection / union : 0;
}

function getBoxCenter(box) {
  return {
    x: (box[0] + box[2]) / 2,
    y: (box[1] + box[3]) / 2
  };
}

function boxesOverlap(box1, box2, iouThreshold) {
  // Check standard IoU
  const iouValue = iou(box1, box2);
  if (iouValue > iouThreshold) return true;
  
  // Also check if one box's center is inside the other box
  const center1 = getBoxCenter(box1);
  const center2 = getBoxCenter(box2);
  
  const center1InBox2 = center1.x >= box2[0] && center1.x <= box2[2] && 
                        center1.y >= box2[1] && center1.y <= box2[3];
  const center2InBox1 = center2.x >= box1[0] && center2.x <= box1[2] && 
                        center2.y >= box1[1] && center2.y <= box1[3];
  
  return center1InBox2 || center2InBox1;
}

function nonMaxSuppression(boxes, iouThreshold) {
  if (boxes.length === 0) return [];
  
  boxes.sort((a, b) => b.conf - a.conf);
  const keep = [];
  
  while (boxes.length > 0) {
    const best = boxes.shift();
    keep.push(best);
    boxes = boxes.filter(box => !boxesOverlap(best.bbox, box.bbox, iouThreshold));
  }
  
  return keep;
}

function confidenceBasedMerge(chaitanyaDetections, sohamDetections) {
  // Combine all detections from both models, grouped by class
  const allDetectionsByClass = {};
  
  // Add Chaitanya detections
  chaitanyaDetections.forEach(det => {
    if (!allDetectionsByClass[det.cls]) {
      allDetectionsByClass[det.cls] = [];
    }
    allDetectionsByClass[det.cls].push(det);
  });
  
  // Add Soham detections (excluding Safe Driving)
  sohamDetections.forEach(det => {
    if (det.cls === 'Safe Driving') return;
    
    if (!allDetectionsByClass[det.cls]) {
      allDetectionsByClass[det.cls] = [];
    }
    allDetectionsByClass[det.cls].push(det);
  });
  
  // Apply NMS per class to remove duplicates but keep separate instances
  const finalDetections = {};
  
  for (const [cls, boxes] of Object.entries(allDetectionsByClass)) {
    // NMS will keep separate instances (different people) but remove duplicate detections of same instance
    const filteredBoxes = nonMaxSuppression(boxes, IOU_THRES);
    
    if (filteredBoxes.length > 0) {
      finalDetections[cls] = filteredBoxes;
    }
  }
  
  return finalDetections;
}


</script>

</body>
</html>